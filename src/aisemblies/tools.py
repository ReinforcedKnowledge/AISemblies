from __future__ import annotations

import inspect
from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import Any, Callable, Union, get_args, get_origin

from docstring_parser import DocstringStyle, ParseError, parse
from pydantic import BaseModel


@dataclass
class ToolCall:
    """
    Represents a single tool call (function call) generated by the model.
    """

    call_id: str
    name: str
    arguments: str
    type: str = "function"


class Tool(ABC):
    """
    Abstract base class for tools (functions).
    """

    @abstractmethod
    def to_openai_dict(self) -> dict:
        """
        Return a dict matching the OpenAI schema for function-calling.

        Returns
        -------
        dict
            A dictionary describing this tool in the style the model expects.
        """
        ...


class FunctionTool(Tool):
    """
    Represents a Python function that can be called by the model.
    """

    def __init__(
        self,
        func: Callable[..., Any],
        name: str | None = None,
        description: str | None = None,
        parameters_schema: dict | None = None,
        strict: bool = False,
    ):
        """
        Initialize a FunctionTool with the given function and metadata.

        Parameters
        ----------
        func : Callable[..., Any]
            The underlying Python function to expose as a tool.
        name : str, optional
            Name of the function to show to the model (defaults to `func.__name__`).
        description : str, optional
            Short description of this function. If omitted or empty, attempts to parse
            from the docstring, else falls back to the raw docstring if parsing fails.
        parameters_schema : dict, optional
            If provided, uses it directly as the JSON schema of the function parameters.
            Otherwise, attempts to generate from the function signature.
        strict : bool, default=False
            Whether the model must strictly adhere to this schema.
        """
        self.func = func
        self._name = name or func.__name__
        self._strict = strict
        self._description = description or self._parse_docstring_description()
        self._parameters_schema = (
            parameters_schema or self._auto_generate_schema()
        )

    @property
    def name(self) -> str:
        """
        Get the name of the function.

        Returns
        -------
        str
            The name of the function.
        """
        return self._name

    @property
    def description(self) -> str:
        """
        Get the description of the function.

        Returns
        -------
        str
            The description of the function.
        """
        return self._description or ""

    @property
    def parameters_schema(self) -> dict:
        """
        Get the JSON schema of the function parameters.

        Returns
        -------
        dict
            The JSON schema representing the function's parameters.
        """
        return self._parameters_schema

    def to_openai_dict(self) -> dict:
        """
        Describe this function in the OpenAI-compatible dictionary format.

        Returns
        -------
        dict
            An object describing this function in the OpenAI style.
        """
        return {
            "type": "function",
            "function": {
                "name": self._name,
                "description": self._description,
                "parameters": self._parameters_schema,
                "strict": self._strict,
            },
        }

    def _parse_docstring_description(self) -> str:
        """
        Attempt to parse the docstring to extract a short description.

        Returns
        -------
        str
            The extracted description or an empty string if not available.
        """
        doc = (self.func.__doc__ or "").strip()
        if not doc:
            return ""
        try:
            parsed = parse(doc, style=DocstringStyle.GOOGLE)
            if parsed.short_description:
                return parsed.short_description.strip()
            if parsed.long_description:
                return parsed.long_description.strip()
            return doc
        except ParseError:
            return doc

    def _auto_generate_schema(self) -> dict:
        """
        Generate a JSON Schema from the function signature and type annotations.

        Returns
        -------
        dict
            The generated JSON schema.

        Raises
        ------
        TypeError
            If a parameter type cannot be transformed into the schema.
        """
        sig = inspect.signature(self.func)
        schema = {"type": "object", "properties": {}, "required": []}

        for param_name, param in sig.parameters.items():
            if param.default is inspect._empty:
                schema["required"].append(param_name)
            annotation = param.annotation
            if annotation is inspect._empty:
                param_schema = {"type": "string"}
            else:
                param_schema = self._annotation_to_schema(
                    annotation, param_name
                )
            schema["properties"][param_name] = param_schema
        return schema

    def _annotation_to_schema(self, annotation: Any, param_name: str) -> dict:
        """
        Convert a type annotation into a JSON Schema object.

        Parameters
        ----------
        annotation : Any
            The type annotation to convert.
        param_name : str
            The name of the parameter being annotated.

        Returns
        -------
        dict
            The JSON Schema representation of the annotation.

        Raises
        ------
        TypeError
            If the annotation type is unsupported.
        """
        if self._is_pydantic_model(annotation):
            return annotation.schema()

        if annotation in (str, bytes):
            return {"type": "string"}
        if annotation is int:
            return {"type": "integer"}
        if annotation is float:
            return {"type": "number"}
        if annotation is bool:
            return {"type": "boolean"}

        origin = get_origin(annotation)
        args = get_args(annotation)

        if origin is list or origin is tuple:
            if len(args) == 1:
                return {
                    "type": "array",
                    "items": self._annotation_to_schema(args[0], param_name),
                }
            else:
                return {
                    "type": "array",
                    "items": [
                        self._annotation_to_schema(a, param_name) for a in args
                    ],
                }

        if origin is dict:
            if len(args) == 2:
                key_type, val_type = args
                if key_type is not str:
                    raise TypeError(
                        f"Unsupported dict key annotation {key_type} for '{param_name}'."
                    )
                return {
                    "type": "object",
                    "additionalProperties": self._annotation_to_schema(
                        val_type, param_name
                    ),
                }
            else:
                return {"type": "object"}

        if origin is Union:
            return {
                "anyOf": [
                    self._annotation_to_schema(a, param_name) for a in args
                ]
            }

        if hasattr(annotation, "__name__"):
            if annotation.__module__ == "builtins":
                return {"type": "string"}
            else:
                raise TypeError(
                    f"Cannot transform parameter '{param_name}' with type '{annotation.__name__}'. "
                    "This behavior is not implemented yet."
                )

        return {"type": "string"}

    @staticmethod
    def _is_pydantic_model(tp: Any) -> bool:
        """
        Check if a given type annotation is a subclass of `pydantic.BaseModel`.

        Parameters
        ----------
        tp : Any
            The type to check.

        Returns
        -------
        bool
            `True` if `tp` is a Pydantic model, else `False`.
        """
        if not isinstance(tp, type):
            return False
        return issubclass(tp, BaseModel)

    def __call__(self, *args, **kwargs) -> Any:
        """
        Allow the FunctionTool instance to be called like a regular function.

        Returns
        -------
        Any
            The result of invoking the underlying function.
        """
        return self.func(*args, **kwargs)


class ToolCollection:
    """
    Holds multiple `FunctionTool` instances and can serialize them for OpenAI usage.
    """

    def __init__(self, tools: list[FunctionTool] | None = None):
        """
        Initialize a ToolCollection with an optional list of tools.

        Parameters
        ----------
        tools : list[FunctionTool], optional
            Initial list of FunctionTool instances to include in the collection.
        """
        self._tools = tools or []

    def add_tool(self, tool: FunctionTool) -> None:
        """
        Add a FunctionTool to the collection.

        Parameters
        ----------
        tool : FunctionTool
            The tool to add.
        """
        self._tools.append(tool)

    def to_openai_list(self) -> list[dict]:
        """
        Serialize all tools in the collection to a list of OpenAI-compatible dictionaries.

        Returns
        -------
        list[dict]
            Serialized representations of the tools.
        """
        return [tool.to_openai_dict() for tool in self._tools]

    def __iter__(self):
        """
        Allow iteration over the tools in the collection.

        Returns
        -------
        Iterator[FunctionTool]
            An iterator over the FunctionTool instances.
        """
        return iter(self._tools)

    def get_tool_by_name(self, name: str) -> FunctionTool | None:
        """
        Retrieve a tool from the collection by its name.

        Parameters
        ----------
        name : str
            The name of the tool to retrieve.

        Returns
        -------
        FunctionTool | None
            The matching FunctionTool if found, else `None`.
        """
        return next((t for t in self._tools if t.name == name), None)
